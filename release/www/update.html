<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>LuminaGrowX – Update</title>
    <link rel="stylesheet" href="/pico.min.css" />
    <style>
      :root{
        --accent:#ef4444;--border:rgba(255,255,255,0.18);--text:#e5e7eb;--text-dim:#cbd5e1;
        --glass:rgba(20,20,22,0.42);--glass-strong:rgba(20,20,22,0.62);
        --radius:18px;--pico-background-color:transparent;--pico-card-background-color:transparent
      }
      html,body{height:100%}
      body{position:relative;color:var(--text);background:transparent}
      body::before{content:"";position:fixed;inset:0;background:linear-gradient(rgba(0,0,0,0.55),rgba(0,0,0,0.55)),url('/bg.jpg') center/cover no-repeat #0b0b0c;z-index:-1}
      article{background:var(--glass);border:1px solid var(--border);border-radius:var(--radius);backdrop-filter:blur(3px)}
      article>header{background:var(--glass-strong);border-bottom:1px solid var(--border);border-radius:var(--radius) var(--radius) 0 0;padding:.75rem 1rem}
      button,[role=button],.button{border-radius:var(--radius)!important}
      pre{white-space:pre-wrap;background:rgba(255,255,255,0.03);border:1px solid var(--border);padding:.75rem;border-radius:12px}
      pre#log{max-height:calc(1.4em * 10); overflow:auto}
      small.dim{color:var(--text-dim)}
      .btn-grid{display:grid;gap:.6rem;grid-template-columns:repeat(auto-fit,minmax(180px,1fr))}
    </style>
  </head>
  <body>
    <main class="container" style="margin-top:1rem">
      <article>
        <header style="display:flex;align-items:center;justify-content:space-between;gap:.5rem">
          <h2>Update</h2>
          <a href="/" role="button">Zurück</a>
        </header>
        <div class="content" style="padding:1rem">
          <p class="dim">Aktuelle Version: <b id="ver">-</b></p>
          <div class="btn-grid">
            <button id="btnCheck">Auf Updates prüfen</button>
            <button id="btnRunRemote" class="primary">Jetzt updaten (Internet)</button>
          </div>
          <div class="grid" style="grid-template-columns:1fr 1fr; gap:.5rem; margin-top:.5rem;">
            <div>Neueste Version: <b id="latest">-</b></div>
            <div>Update verfügbar: <b id="updflag">-</b></div>
          </div>
          <div class="grid" style="grid-template-columns:1fr; gap:.5rem;">
            <div>
              <small class="dim">Fortschritt</small>
              <progress id="prog" max="100" value="0"></progress>
              <div><small id="progText" class="dim">-</small></div>
            </div>
          </div>
          <pre id="log" style="margin-top:.5rem"></pre>
          <hr />
          <h3>Manuelles Paket (.tar) hochladen</h3>
          <form id="f">
            <input type="file" id="pkg" accept=".tar" />
            <button class="primary">Upload & Anwenden</button>
          </form>
        </div>
      </article>
    </main>

    <script>
      const ver = document.getElementById('ver');
      const log = document.getElementById('log');
      const btnC = document.getElementById('btnCheck');
      const btnR = document.getElementById('btnRunRemote');
      const latest = document.getElementById('latest');
      const updflag = document.getElementById('updflag');
      const prog = document.getElementById('prog');
      const progText = document.getElementById('progText');

      let preFw = null, preBuild = null, expectedFw = null;
      function add(m){ log.textContent += m + "\n"; log.scrollTop = log.scrollHeight; }

      fetch('/api/status').then(r=>r.json()).then(j=>{ ver.textContent = j.fw || '-'; preFw = j.fw||null; preBuild = j.build||null; }).catch(()=>{});

      function waitForReboot(expectFw){
        add('Warte auf Neustart...');
        const ping = () => {
          fetch('/api/status', {cache:'no-store'}).then(r=>r.json()).then(j=>{
            const fwOk = expectFw ? (j.fw === expectFw) : ((j.build && preBuild) ? (j.build !== preBuild) : (j.fw && preFw ? (j.fw !== preFw) : false));
            if (fwOk) {
              ver.textContent = j.fw || '-';
              add('Gerät wieder online – Update erfolgreich');
            } else { setTimeout(ping, 1500); }
          }).catch(()=> setTimeout(ping, 1500));
        };
        setTimeout(ping, 1500);
      }

      let lastPhase = null;
      function phaseText(ph){
        switch(String(ph||'')){
          case 'uploading': return 'Hochladen...';
          case 'downloading': return 'Lade Update herunter...';
          case 'checking': return 'Prüfe Update-Quelle...';
          case 'applying': return 'Entpacken und anwenden...';
          case 'done': return 'Abgeschlossen';
          case 'error': return 'Fehler';
          default: return String(ph||'-');
        }
      }
      function pollProgress(){
        fetch('/api/update/progress').then(r=>r.json()).then(j=>{
          if (j.phase && j.phase !== lastPhase){
            add('Phase: ' + phaseText(j.phase));
            lastPhase = j.phase;
          }
          if (j.msg) add('['+j.phase+'] '+j.msg);
          let pct = -1, txt = '-';
          if (j.download){ pct = Math.max(0, j.download.pct||0); txt = (j.download.sofar||0)+' / '+(j.download.total||0); }
          if (j.apply && (j.apply.pct||0) >= 0){ pct = Math.max(pct, j.apply.pct||0); txt = (j.apply.sofar||0)+' / '+(j.apply.total||0); }
          if (pct >= 0){ prog.value = pct; progText.textContent = txt; }
          if (!j.running){
            if (j.ok){
              add('Update erfolgreich '+ (j.fwUpdated?'(Firmware + Web-Assets)':'(Web-Assets)'));
              if (j.fwUpdated) { add('Reboot...'); waitForReboot(expectedFw||null); }
              else { add('Kein Neustart erforderlich.'); }
            } else {
              add('Update fehlgeschlagen: '+(j.error||'unbekannt'));
            }
          } else {
            setTimeout(pollProgress, 1000);
          }
        }).catch(()=> setTimeout(pollProgress, 1500));
      }

      btnC.onclick = () => {
        add('Neueste Version wird ermittelt...');
        fetch('/api/update/check').then(r=>r.json()).then(j=>{
          latest.textContent = j.latest || '-';
          updflag.textContent = j.hasUpdate ? 'Ja' : 'Nein';
          expectedFw = j.latest || null;
          add('Neueste Version: ' + (j.latest||'-') + ', Update verfügbar: ' + (j.hasUpdate?'Ja':'Nein'));
        }).catch(e=> add('Fehler beim Prüfen: ' + e));
      };

      btnR.onclick = () => {
        add('Starte Remote-Update...');
        fetch('/api/status', {cache:'no-store'}).then(r=>r.json()).then(j=>{
          if (!j || !j.internet_ok){ add('Kein Internet vorhanden'); throw new Error('no internet'); }
        }).then(()=>
        fetch('/api/update/remote', { method: 'POST' }))
          .then(r=>{ if (r.status===202) { add('Update gestartet'); pollProgress(); } else { return r.text().then(t=>{ throw new Error(t) }) } })
          .catch(e=> add('Fehler beim Start: ' + e));
      };

      document.getElementById('f').onsubmit = (e) => {
        e.preventDefault();
        const f = document.getElementById('pkg').files[0];
        if (!f) { alert('Bitte .tar wählen'); return; }
        const fd = new FormData(); fd.append('package', f);
        add('Lade hoch und starte Anwendung...');
        const xhr = new XMLHttpRequest();
        xhr.open('POST', '/api/update/upload');
        xhr.upload.onprogress = (ev) => {
          if (ev.lengthComputable) {
            const pct = Math.round(ev.loaded * 100 / ev.total);
            prog.value = pct; progText.textContent = ev.loaded + ' / ' + ev.total;
            if (pct % 10 === 0) add('[uploading] ' + ev.loaded + ' / ' + ev.total + ' ('+pct+'%)');
          } else {
            progText.textContent = ev.loaded + ' bytes';
          }
        };
        let pollStarted = false;
        const startPollOnce = () => { if (!pollStarted){ pollStarted = true; lastPhase = null; pollProgress(); } };
        // Falls die Verbindung während des Uploads zurückgesetzt wird (Status 0), direkt mit Polling weitermachen
        xhr.onerror = () => { add('Upload-Verbindung unterbrochen, prüfe Fortschritt...'); startPollOnce(); };
        xhr.ontimeout = () => { add('Upload-Zeitüberschreitung, prüfe Fortschritt...'); startPollOnce(); };
        xhr.onreadystatechange = () => {
          if (xhr.readyState === 4) {
            if (xhr.status === 202) { add('Anwendung gestartet'); startPollOnce(); }
            else if (xhr.status === 0) { add('Upload abgeschlossen (Netzwerk wechsel/Reset vermutet). Prüfe Fortschritt...'); startPollOnce(); }
            else { add('Fehler beim Upload: ' + xhr.status + ' ' + (xhr.responseText||'')); }
          }
        };
        xhr.send(fd);
        // Sicherheitsnetz: starte Polling kurz nach Upload-Start, falls keine Antwort kommt
        setTimeout(()=>{ startPollOnce(); }, 1500);
      };
    </script>
  </body>
  </html>
