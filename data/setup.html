<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Lisa Pro – Setup</title>
    <link rel="stylesheet" href="/pico.min.css" />
    <style>
      :root {
        --accent: #ef4444;
        --accent-2: #dc2626;
        --glass: rgba(20, 20, 22, 0.42);
        --glass-strong: rgba(20, 20, 22, 0.62);
        --muted: rgba(255, 255, 255, 0.06);
        --border: rgba(255, 255, 255, 0.18);
        --text: #e5e7eb;
        --text-dim: #cbd5e1;
        --ok: #22c55e;
        --warn: #f59e0b;
        --err: #ef4444;
        --radius: 18px;
        --pico-background-color: transparent;
        --pico-card-background-color: transparent;
      }
      html,
      body {
        height: 100%;
      }
      body {
        position: relative;
        color: var(--text);
        background: transparent;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background: linear-gradient(rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0.55)),
          url("/bg.jpg") center/cover no-repeat #0b0b0c;
        z-index: -1;
      }
      header.hero {
        background: var(--glass);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        backdrop-filter: blur(3px);
      }
      header.hero h1.brand {
        font-size: clamp(2.2rem, 6vw, 3.3rem);
        letter-spacing: 0.04em;
        margin: 0.25rem 0 0;
      }
      article {
        background: var(--glass);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        backdrop-filter: blur(3px);
        margin-bottom: 0; /* Reset margin for grid context */
        height: 100%;     /* Equal height in grid */
      }
      article > header {
        background: var(--glass-strong);
        border-bottom: 1px solid var(--border);
        border-radius: var(--radius) var(--radius) 0 0;
        padding: 0.75rem 1rem;
      }
      .grid {
        gap: 1rem;
      }
      .hidden {
        display: none;
      }
      input,
      select,
      button,
      [role="button"],
      .button {
        border-radius: var(--radius) !important;
      }
      /* Group fixes for radius */
      [role="group"] input:not(:first-child),
      [role="group"] button:not(:first-child) {
        border-top-left-radius: 0 !important;
        border-bottom-left-radius: 0 !important;
        margin-left: -1px;
      }
      [role="group"] input:not(:last-child),
      [role="group"] button:not(:last-child) {
        border-top-right-radius: 0 !important;
        border-bottom-right-radius: 0 !important;
      }

      input,
      select {
        background: rgba(255, 255, 255, 0.02) !important;
        color: var(--text) !important;
        border: 1px solid var(--border) !important;
      }
      button,
      [role="button"],
      .button {
        background: rgba(20, 20, 22, 0.42);
        color: var(--text);
        border: 1px solid var(--border);
        font-weight: 700;
        font-size: 1rem;
        line-height: 1.5; /* Uniform line-height */
        padding: 0.55rem 0.9rem;
        border-radius: var(--radius) !important;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        white-space: nowrap;
        min-height: 2.8rem; /* Force minimum height for A and BUTTON tags */
        box-sizing: border-box; /* Ensure padding includes border */
        cursor: pointer;
      }
      @media (min-width: 768px) {
        button,
        [role="button"],
        .button {
          font-size: 0.95rem;
          padding: 0.5rem 0.85rem;
        }
      }
      @media (min-width: 1200px) {
        button,
        [role="button"],
        .button {
          font-size: 0.9rem;
          padding: 0.45rem 0.8rem;
        }
      }
      button:hover,
      [role="button"]:hover,
      .button:hover {
        background: rgba(255, 255, 255, 0.06);
      }
      button:active,
      button.primary,
      .primary {
        background: var(--accent) !important;
        color: #fff !important;
        border-color: var(--accent) !important;
      }
      button.success, .success {
        background: var(--ok) !important;
        color: #fff !important;
        border-color: var(--ok) !important;
      }
      button.secondary, .secondary {
        background: transparent;
        border-color: var(--border);
        color: var(--text-dim);
      }
      button.secondary:hover, .secondary:hover {
        color: var(--text);
        border-color: var(--text);
      }
      input[type="checkbox"],
      input[type="radio"] {
        accent-color: var(--accent);
      }
      input[type="checkbox"] {
        width: 1.1rem;
        height: 1.1rem;
        margin-right: 0.5rem;
        border: 2px solid var(--border) !important;
        background: rgba(255, 255, 255, 0.06) !important;
        cursor: pointer;
      }
      input[type="checkbox"]:checked {
        background: var(--accent) !important;
        border-color: var(--accent) !important;
      }
      label > input[type="checkbox"] {
        vertical-align: middle;
      }
      .ok {
        color: var(--ok);
      }
      .err {
        color: var(--err);
      }
      .warn {
        color: var(--warn);
      }
      .card {
        /* Remove internal padding of card div inside content, 
           as we now use articles as cards directly in grid */
        /* But here we have .card inside .content inside article. 
           Keep simple. */
      }
      .badge {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        font-size: 0.85rem;
        white-space: nowrap;
        flex-shrink: 0;
        padding: 0.25rem 0.5rem;
        border-radius: 999px;
        background: var(--glass-strong);
        border: 1px solid var(--border);
      }
      .brand-word {
        color: #ffffff;
        font-weight: 800;
      }
      .brand-pro {
        color: var(--accent);
        font-weight: 800;
        font-size: 0.55em;
        line-height: 1;
        vertical-align: super;
        position: relative;
        top: -0.25em;
      }
      button:focus, [role="button"]:focus, .button:focus {
        box-shadow: none !important;
        outline: none !important;
      }
      .btn-row {
        display: flex;
        gap: 0.5rem;
      }
      .btn-row > button, .btn-row > a, .btn-row > input {
        flex: 1;
      }
      /* Helper from custom.css mirrored here for safety/completeness */
      .help-details {
        margin-top: 0.75rem;
        padding-top: 0.5rem;
        border-top: 1px solid var(--border);
      }
      .help-details summary {
        font-size: 0.8rem;
        color: var(--text-dim);
        cursor: pointer;
        margin-bottom: 0.25rem;
      }
      .help-details summary::after {
        content: " ℹ️";
        font-size: 0.9em;
        opacity: 0.7;
      }
      .help-details small {
        display: block;
        margin-top: 0.25rem;
        color: var(--text-dim);
        font-size: 0.85rem;
        line-height: 1.4;
      }
    </style>
  </head>
  <body>
    <header class="hero container" style="margin-top: 1rem; padding: 1rem;">
      <h1 class="brand">
        <span class="brand-word">LISA</span><span class="brand-pro">pro</span>
      </h1>
      <p class="subtitle" style="margin: 0.25rem 0 0; opacity: 0.85; color: var(--text-dim);">Setup und Einrichtung</p>
    </header>

    <main class="container" style="display: grid; gap: 1rem; margin-top: 1rem;">
      <!-- RTC -->
      <article>
        <header
          style="
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
          "
        >
          <h3>Uhrzeit (RTC)</h3>
          <span class="badge" id="b_rtc_top">RTC</span>
        </header>
        <div class="content" style="padding: 1rem; display: grid; gap: 1rem">
          <small
            id="modulesMsg"
            class="mono"
            style="opacity: 0.8; display: block"
          ></small>
          
          <div class="btn-row">
            <input
              id="rtcDt"
              type="datetime-local"
              aria-label="Datetime local"
            />
            <button id="rtcSet" type="button" class="primary">
              Setzen
            </button>
          </div>
          
          <small id="rtcState">Status: -</small>
          <label style="display: block;"
            ><input type="checkbox" id="cb_rtc" /> RTC eingestellt</label
          >
          <details class="help-details">
            <summary>Hilfe</summary>
            <small>I2C-Verbindung und Knopfzelle prüfen; nach Uhr-Setzen Badge beobachten.</small>
          </details>
        </div>
      </article>

      <!-- SHT SENSORS ROW -->
      <div class="grid">
        <!-- SHT IN -->
        <article>
          <header
            style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              gap: 0.5rem;
            "
          >
            <h3>SHT Innen</h3>
            <span class="badge" id="b_sht_in">Innen</span>
          </header>
          <div class="content" style="padding: 1rem; display: grid; gap: 1rem">
            <h4 id="shtInHdr"></h4>
            <div>Messwert: <strong id="shtIn">-</strong></div>
            <label style="display: block;"
              ><input type="checkbox" id="cb_sht" /> Geprüft</label
            >
            <details class="help-details">
              <summary>Hilfe</summary>
              <small>Sensor kurz anpusten/erwärmen; Verkabelung an I2C (Wire1) prüfen.</small>
            </details>
          </div>
        </article>

        <!-- SHT OUT -->
        <article>
          <header
            style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              gap: 0.5rem;
            "
          >
            <h3>SHT Außen</h3>
            <span class="badge" id="b_sht_out">Außen</span>
          </header>
          <div class="content" style="padding: 1rem; display: grid; gap: 1rem">
            <h4 id="shtOutHdr"></h4>
            <div>Messwert: <strong id="shtOut">-</strong></div>
            <label style="display: block;"
              ><input type="checkbox" id="cb_sht_out" /> Geprüft</label
            >
            <details class="help-details">
              <summary>Hilfe</summary>
              <small>Sensor kurz anpusten/erwärmen; Verkabelung an I2C (Wire) prüfen.</small>
            </details>
          </div>
        </article>
      </div>

      <!-- ToF & Door ROW -->
      <div class="grid">
        <!-- ToF -->
        <article>
          <header
            style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              gap: 0.5rem;
            "
          >
            <h3>ToF Sensor</h3>
            <span class="badge" id="b_tof">ToF</span>
          </header>
          <div class="content" style="padding: 1rem; display: grid; gap: 1rem">
            <p style="margin-bottom:0.5rem">Kalibrierwerkzeug (50mm) anlegen.</p>
            <div class="btn-row">
              <button id="tofCal" type="button" class="primary">
                Kalibrieren
              </button>
            </div>
            <small id="tofMsg">–</small>
            
            <div>
              Aktuell: <strong id="tofLive">-</strong> mm
              <small>(Off: <span id="tofOff">0</span>)</small>
            </div>
            <label style="display: block;"
              ><input type="checkbox" id="cb_tof" /> Kalibriert</label
            >
            <details class="help-details">
              <summary>Hilfe</summary>
              <small>XSHUT-Pin High, Kalibrierwerkzeug plan anlegen; Kabel/Adresse 0x29 prüfen.</small>
            </details>
          </div>
        </article>

        <!-- Tür -->
        <article>
          <header
            style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              gap: 0.5rem;
            "
          >
            <h3>Tür</h3>
            <span class="badge" id="b_door">Tür</span>
          </header>
          <div class="content" style="padding: 1rem; display: grid; gap: 1rem">
            <div>Status: <strong id="doorState">unbekannt</strong></div>
            <label style="display: block;"
              ><input type="checkbox" id="cb_door" /> Türerkennung ok</label
            >
            <details class="help-details">
              <summary>Hilfe</summary>
              <small>Schalter verdrahtet? interner Pullup aktiv? Pegel beachten (LOW = geschlossen).</small>
            </details>
          </div>
        </article>
      </div>

      <!-- FANS ROW -->
      <div class="grid">
        <!-- Lüfter 1 -->
        <article>
          <header
            style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              gap: 0.5rem;
            "
          >
            <h3>Lüfter 1</h3>
            <span class="badge" id="b_fan">Fan 1</span>
          </header>
          <div class="content" style="padding: 1rem; display: grid; gap: 1rem">
            <div class="btn-row">
              <button id="fanOff" type="button" class="primary">Aus</button>
              <button id="fanOn" type="button" class="secondary">
                An
              </button>
            </div>
            <div>Drehzahl: <strong id="fanRpm">-</strong> RPM</div>
            <label style="display: block;"
              ><input type="checkbox" id="cb_fan" /> Test ok</label
            >
            <details class="help-details">
              <summary>Hilfe</summary>
              <small>Lüfter nicht angeschlossen, Lüfter defekt oder Tacho/PWM vertauscht?</small>
            </details>
          </div>
        </article>

        <!-- Lüfter 2 -->
        <article>
          <header
            style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              gap: 0.5rem;
            "
          >
            <h3>Lüfter 2</h3>
            <span class="badge" id="b_fan2">Fan 2</span>
          </header>
          <div class="content" style="padding: 1rem; display: grid; gap: 1rem">
            <div class="btn-row">
              <button id="fan2Off" type="button" class="primary">Aus</button>
              <button id="fan2On" type="button" class="secondary">
                An
              </button>
            </div>
            <div>Drehzahl: <strong id="fan2Rpm">-</strong> RPM</div>
            <label style="display: block;"
              ><input type="checkbox" id="cb_fan2" /> Test ok</label
            >
            <details class="help-details">
              <summary>Hilfe</summary>
              <small>Lüfter nicht angeschlossen, Lüfter defekt oder Tacho/PWM vertauscht?</small>
            </details>
          </div>
        </article>
      </div>

      <!-- LED & Stepper ROW -->
      <div class="grid">
        <!-- LED (DAC) -->
        <article>
          <header
            style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              gap: 0.5rem;
            "
          >
            <h3>LED (DAC)</h3>
            <span class="badge" id="b_dac">LED</span>
          </header>
          <div class="content" style="padding: 1rem; display: grid; gap: 1rem">
            <div class="btn-row">
              <button id="ledOff" type="button" class="primary">Aus</button>
              <button id="ledOn" type="button" class="secondary">
                An
              </button>
            </div>
            <label style="display: block;"
              ><input type="checkbox" id="cb_led" /> Test ok</label
            >
            <details class="help-details">
              <summary>Hilfe</summary>
              <small>GP8211 I2C (0x58) und 0–10V-Leitung prüfen; Last beachten.</small>
            </details>
          </div>
        </article>

        <!-- Stepper -->
        <article>
          <header
            style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              gap: 0.5rem;
            "
          >
            <h3>Steppermotor</h3>
            <span class="badge" id="b_step">Stepper</span>
          </header>
          <div class="content" style="padding: 1rem; display: grid; gap: 1rem">
            <button id="stepHome" type="button" class="primary">Homing Starten</button>
            <div class="btn-row">
              <button id="stepDown" type="button" class="primary" disabled>▼ 1 cm</button>
              <button id="stepUp" type="button" class="primary" disabled>
                ▲ 1 cm
              </button>
            </div>
            <small id="stepMsg" style="display: block; min-height: 1.2em;">–</small>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
              <label><input type="checkbox" id="cb_step_home" /> Homing ok</label>
              <label><input type="checkbox" id="cb_step_jog" /> Jog ok</label>
            </div>
            <details class="help-details">
              <summary>Hilfe</summary>
              <small>Mechanik freigängig, Endlagen; Homing nur durchführen, wenn Jog ok.</small>
            </details>
          </div>
        </article>
      </div>

      <!-- Abschluss -->
      <article>
        <header
          style="
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
          "
        >
          <h3>Abschluss</h3>
        </header>
        <div class="content" style="padding: 1rem; display: grid; gap: 1rem">
          <p style="font-size: 0.9rem; opacity: 0.8; margin-bottom: 0;">
             Sind alle Tests erfolgreich abgeschlossen? Nach dem Klick auf "Abschließen" startet das System neu.
          </p>
          <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
            <a href="/settings" role="button" class="secondary" style="margin-right: auto;">Zurück</a>
            <button id="btnAbort" type="button" class="secondary">Abbruch</button>
            <button id="btnDone" type="button" class="primary" disabled>
              Abschließen & Neustart
            </button>
          </div>
        </div>
      </article>
    </main>

    <dialog id="toast" class="modal">
      <article>
        <header><strong>Status</strong></header>
        <div class="content" style="padding: 1rem">
          <p id="toastMsg">-</p>
        </div>
        <footer
          style="
            display: flex;
            justify-content: flex-end;
            padding: 0.75rem 1rem;
          "
        >
          <button onclick="document.getElementById('toast').close()">OK</button>
        </footer>
      </article>
    </dialog>

    <script>
      const $ = (id) => document.getElementById(id);
      function showToast(msg) {
        $("toastMsg").textContent = msg;
        $("toast").showModal();
      }
      async function fetchJSON(url, options) {
        const r = await fetch(
          url,
          Object.assign(
            { headers: { "Content-Type": "application/json" } },
            options || {}
          )
        );
        if (!r.ok)
          throw new Error(
            await r.text().catch(() => r.status + " " + r.statusText)
          );
        return await r.json().catch(() => ({}));
      }

      function setBadge(elId, ok, hint) {
        const el = $(elId);
        if (!el) return;
        el.classList.remove("ok", "err");
        el.classList.add(ok ? "ok" : "err");
        el.title = ok ? "OK" : hint || "Bitte Verkabelung/Spannung prüfen";
      }

      let ws = null,
        wsTimer = null;
      function connectWS() {
        try {
          const proto = location.protocol === "https:" ? "wss" : "ws";
          ws = new WebSocket(proto + "://" + location.host + "/ws");
          ws.addEventListener("message", (ev) => {
            try {
              const j = JSON.parse(ev.data);
              if (j && j.health && j.health.modules) {
                const m = j.health.modules;
                setBadge("b_i2c0", m.i2c0);
                setBadge("b_i2c1", m.i2c1);
                setBadge(
                  "b_sht_in",
                  m.sht_in,
                  "SHT innen – bitte Kabel prüfen und Sensor erwärmen"
                );
                setBadge(
                  "b_sht_out",
                  m.sht_out,
                  "SHT außen – bitte Kabel prüfen und Sensor erwärmen"
                );
                setBadge("b_tof", m.tof, "ToF – Kabel/XSHUT prüfen");
                setBadge("b_dac", m.dac, "GP8211 – I2C prüfen");
                
                // Fan 1 Module check (only basic module check here)
                if (m.fan === false) setBadge("b_fan", false, "PWM/Lüfter prüfen");
                
                setBadge("b_rtc", m.rtc, "RTC – I2C/Knopfzelle prüfen");
                setBadge("b_rtc_top", m.rtc);
                setBadge("b_fs", m.fs, "LittleFS");
                
                const lines = [];
                if (m.sht_in === false) lines.push("SHT innen fehlt");
                if (m.sht_out === false) lines.push("SHT außen fehlt");
                if (m.dac === false)
                  lines.push("LED-DAC (GP8211) nicht erreichbar");
                if (m.fan === false) lines.push("Lüfter-PWM Fehler");
                if (m.rtc === false)
                  lines.push("RTC (DS3231) nicht erreichbar");
                if (m.tof === false) lines.push("ToF-Sensor nicht erreichbar");
                if (m.fs === false) lines.push("Dateisystem (LittleFS) Fehler");
                $("modulesMsg").textContent = lines.length
                  ? "Hinweise: " + lines.join(" | ")
                  : "";
              }
              if (j) {
                // Live updates here if needed, but polling refreshStatus handles badges mostly
              }
            } catch (_) {}
          });
          ws.addEventListener("close", () => {
            ws = null;
            wsTimer = setTimeout(connectWS, 2000);
          });
          ws.addEventListener("error", () => {
            try {
              ws && ws.close();
            } catch (_) {}
          });
        } catch (_) {}
      }

      function updateToggleBtns(offId, onId, isOn) {
        const off = $(offId);
        const on = $(onId);
        if (off && on) {
          if (isOn) {
            // ON: On=Green(Success), Off=Transparent
            on.classList.add("success");
            on.classList.remove("secondary", "primary"); 
            off.classList.remove("primary", "success");
            off.classList.add("secondary");
          } else {
            // OFF: Off=Red(Primary), On=Transparent
            off.classList.add("primary");
            off.classList.remove("secondary", "success");
            on.classList.remove("primary", "success");
            on.classList.add("secondary");
          }
        }
      }

      async function refreshStatus() {
        let st = {};
        try {
          st = await fetchJSON("/api/setup/status");
          $("rtcState").textContent =
            "Status: " + (st.rtc_ok ? "RTC OK" : "RTC nicht erreichbar");
          const m = st.modules || {};
          setBadge("b_i2c0", m.i2c0);
          setBadge("b_i2c1", m.i2c1);
          setBadge("b_sht_in", m.sht_in);
          setBadge("b_sht_out", m.sht_out);
          setBadge("b_tof", m.tof);
          setBadge("b_dac", m.dac);
          
          // Basic module status first
          if (m.fan === false) setBadge("b_fan", false, "PWM/Lüfter prüfen");
          else {
             const fb = $("b_fan");
             if(fb) { fb.classList.remove("ok","err"); fb.title="Aus"; }
          }

          setBadge("b_rtc", m.rtc);
          setBadge("b_rtc_top", m.rtc);
          setBadge("b_fs", m.fs);
          
          const setCheckHdr = (id, bad) => {
            const el = $(id);
            if (!el) return;
            if (bad) {
              el.textContent = "Sensor überprüfen";
              el.classList.add("err");
            } else {
              el.textContent = "";
              el.classList.remove("err");
            }
          };
          setCheckHdr("shtInHdr", !m.sht_in);
          setCheckHdr("shtOutHdr", !m.sht_out);
        } catch (e) {}
        try {
          const live = await fetchJSON("/api/status");
          const tIn = live && live.temp_c,
            hIn = live && live.humi_rh,
            tOut = live && live.temp_out_c,
            hOut = live && live.humi_out_rh;
          $("shtIn").textContent =
            (Number.isFinite(tIn) ? tIn.toFixed(1) + " °C" : "-") +
            ", " +
            (Number.isFinite(hIn) ? hIn.toFixed(1) + " %" : "-");
          $("shtOut").textContent =
            (Number.isFinite(tOut) ? tOut.toFixed(1) + " °C" : "-") +
            (Number.isFinite(hOut) ? ", " + hOut.toFixed(1) + " %" : "");
          // Falls Werte fehlen, betroffene Badges rot setzen
          if (!(Number.isFinite(tIn) && Number.isFinite(hIn)))
            setBadge("b_sht_in", false, "Keine Werte");
          if (!(Number.isFinite(tOut) && Number.isFinite(hOut)))
            setBadge("b_sht_out", false, "Keine Werte");
          
          // Fan 1 & 2 Badge Logic
          try {
            // Fan 1
            const fanRpm = (st.fan_rpm || (live && live.fan_rpm)) ? (st.fan_rpm || live.fan_rpm) : 0;
            const fanOn = (live && !!live.fan_on); 
            updateToggleBtns("fanOff", "fanOn", fanOn);
            $("fanRpm").textContent = fanRpm;
            
            const el = $("b_fan");
            if (el) {
              // Priority: Module Error -> Red. Done above in st block.
              // If module ok, check state:
              if (!el.classList.contains("err") || el.title.includes("0 RPM") || el.title.includes("Aus")) { 
                  el.classList.remove("ok", "err"); // Reset to neutral (white/grey)
                  
                  if (fanRpm > 0) {
                     el.classList.add("ok");
                     el.title = "Läuft (" + fanRpm + " RPM)";
                  } else if (fanOn && fanRpm === 0) {
                     el.classList.add("err");
                     el.title = "An aber 0 RPM!";
                  } else {
                     // Off -> Neutral
                     el.title = "Aus";
                  }
              }
            }

            // Fan 2 (No global badge yet, just UI text)
            const fan2Rpm = (st.fan2_rpm || (live && live.fan2_rpm)) ? (st.fan2_rpm || live.fan2_rpm) : 0;
            const fan2On = (live && !!live.fan2_on);
            updateToggleBtns("fan2Off", "fan2On", fan2On);
            const el2 = $("fan2Rpm");
            if (el2) el2.textContent = fan2Rpm;
            
            const b2 = $("b_fan2");
            if (b2) {
               // Fan 2 Logic mirroring Fan 1
               // Default (OFF) -> White/Neutral
               b2.classList.remove("ok", "err");
               b2.title = "Aus";
               
               if (fan2Rpm > 0) {
                  b2.classList.add("ok");
                  b2.title = "Läuft (" + fan2Rpm + " RPM)";
               } else if (fan2On && fan2Rpm === 0) {
                  b2.classList.add("err");
                  b2.title = "An aber 0 RPM!";
               }
            }
          } catch (_) {}
          
          // LED Buttons
          if (live) {
             updateToggleBtns("ledOff", "ledOn", !!live.light_on);
          }

          // ToF live
          try {
            const st2 = await fetchJSON("/api/setup/status");
            if (typeof st2.tof_mm !== "undefined") {
              const v = st2.tof_mm;
              $("tofLive").textContent =
                v >= 0 ? v : v === -2 ? "zu nah" : "Fehler";
            }
            if (typeof st2.tof_offset !== "undefined") {
              $("tofOff").textContent = st2.tof_offset;
            }
          } catch (_) {}

          // Prefill datetime
          if (!$("rtcDt").value && live && live.ntp_time) {
            const m = live.ntp_time.match(/(\d{1,2})[\.\-](\d{1,2})[\.\-](\d{2,4})\s+(\d{1,2})[\:\-](\d{1,2})[\:\-](\d{1,2})/);
            if (m) {
              let y = Number(m[3]);
              if (y < 100) y += 2000;
              const iso = 
                y + '-' + 
                String(Number(m[2])).padStart(2,'0') + '-' + 
                String(Number(m[1])).padStart(2,'0') + 'T' + 
                String(Number(m[4])).padStart(2,'0') + ':' + 
                String(Number(m[5])).padStart(2,'0');
              $("rtcDt").value = iso;
            }
          }
        } catch (e) {}
      }

      function fmtDDMMYYYY_HHMMSS(dt) {
        const dd = String(dt.getDate()).padStart(2, "0");
        const mm = String(dt.getMonth() + 1).padStart(2, "0");
        const yyyy = dt.getFullYear();
        const HH = String(dt.getHours()).padStart(2, "0");
        const MM = String(dt.getMinutes()).padStart(2, "0");
        const SS = String(dt.getSeconds()).padStart(2, "0");
        return `${dd}-${mm}-${yyyy} ${HH}-${MM}-${SS}`;
      }
      $("rtcSet").addEventListener("click", async () => {
        const v = $("rtcDt").value;
        if (!v) {
          showToast("Bitte Datum/Zeit wählen");
          return;
        }
        const dt = new Date(v);
        if (isNaN(dt.getTime())) {
          showToast("Ungültiges Datum/Zeit");
          return;
        }
        const time = fmtDDMMYYYY_HHMMSS(dt);
        try {
          const r = await fetchJSON("/api/rtc/set", {
            method: "POST",
            body: JSON.stringify({ time }),
          });
          if (r.ok) {
            $("cb_rtc").checked = true;
            showToast("RTC gesetzt");
          } else {
            showToast("RTC setzen fehlgeschlagen");
          }
          refreshStatus();
          updateDoneEnabled();
        } catch (e) {
          showToast("Fehler: " + e.message);
        }
      });
      $("tofCal").addEventListener("click", async () => {
        try {
          const r = await fetchJSON("/api/tof/calibrate", {
            method: "POST",
            body: "{}",
          });
          $("tofMsg").textContent = r.ok
            ? "OK (gemessen " + r.measured + " mm, Offset " + r.offset + " mm)"
            : "Fehler";
          if (r.ok) $("cb_tof").checked = true;
          refreshStatus();
          updateDoneEnabled();
        } catch (e) {
          $("tofMsg").textContent = "Fehler: " + e.message;
        }
      });
      $("ledOff").addEventListener("click", () =>
        fetch("/api/dac", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ on: false }),
        })
      );
      $("ledOn").addEventListener("click", () =>
        fetch("/api/dac", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ on: true }),
        })
      );
      $("fanOff").addEventListener("click", () =>
        fetch("/api/fan", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ on: false }),
        })
      );
      $("fanOn").addEventListener("click", () =>
        fetch("/api/fan", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ on: true }),
        })
      );
      $("fan2Off").addEventListener("click", () =>
        fetch("/api/fan2", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ on: false }),
        })
      );
      $("fan2On").addEventListener("click", () =>
        fetch("/api/fan2", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ on: true }),
        })
      );
      $("stepUp").addEventListener("click", async () => {
        const b = $("stepUp");
        if(b) { b.textContent="Fährt..."; b.classList.add("success"); b.dataset.moving="1"; b.disabled=true; }
        try {
          await fetchJSON("/api/stepper/jog", {
            method: "POST",
            body: JSON.stringify({ dir: "up", mm: 10 }),
          });
          $("stepMsg").textContent = "Move hoch gestartet";
        } catch (e) {
          $("stepMsg").textContent = "Fehler: " + e.message;
          if(b) { b.textContent="▲ 1 cm"; b.classList.remove("success"); delete b.dataset.moving; b.disabled=false; }
        }
      });
      $("stepDown").addEventListener("click", async () => {
        const b = $("stepDown");
        if(b) { b.textContent="Fährt..."; b.classList.add("success"); b.dataset.moving="1"; b.disabled=true; }
        try {
          await fetchJSON("/api/stepper/jog", {
            method: "POST",
            body: JSON.stringify({ dir: "down", mm: 10 }),
          });
          $("stepMsg").textContent = "Move runter gestartet";
        } catch (e) {
          $("stepMsg").textContent = "Fehler: " + e.message;
          if(b) { b.textContent="▼ 1 cm"; b.classList.remove("success"); delete b.dataset.moving; b.disabled=false; }
        }
      });
      $("stepHome").addEventListener("click", async () => {
        try {
          const btn = $("stepHome");
          if(btn) btn.disabled = true; // Disable immediately to prevent double-click
          const r = await fetchJSON("/api/stepper/home", { method: "POST" });
          $("stepMsg").textContent = r.ok
            ? "Homing gestartet"
            : "Homing konnte nicht gestartet werden";
        } catch (e) {
          // If message is JSON object, parse it
          let msg = e.message;
          if (msg.includes("ok")) msg = "Fehler (Busy?)";
          $("stepMsg").textContent = "Homing Info: " + msg;
        }
      });
      function updateDoneEnabled() {
        const need = [
          "cb_rtc",
          "cb_sht",
          "cb_sht_out",
          "cb_tof",
          "cb_led",
          "cb_fan",
          "cb_fan2",
          "cb_step_jog",
          "cb_step_home",
          "cb_door",
        ];
        const all = need.every((id) => $(id) && $(id).checked);
        $("btnDone").disabled = !all;
      }
      [
        "cb_rtc",
        "cb_sht",
        "cb_sht_out",
        "cb_tof",
        "cb_led",
        "cb_fan",
        "cb_fan2",
        "cb_step_jog",
        "cb_step_home",
        "cb_door",
      ].forEach((id) => {
        const el = $(id);
        if (el) el.addEventListener("change", updateDoneEnabled);
      });

      async function pollDoor() {
        try {
          const d = await fetchJSON("/api/door/status");
          const el = $("b_door");
          if (d && d.present) {
            const closed = !!d.closed;
            $("doorState").textContent = closed ? "geschlossen" : "offen";
            if (el) {
              el.classList.remove("ok", "err");
              el.title = closed ? "geschlossen" : "offen";
            }
          } else {
            $("doorState").textContent = "nicht vorhanden";
            if (el) {
              el.classList.remove("ok", "err");
              el.title = "Nicht vorhanden";
            }
          }
        } catch (_) {
          const el = $("b_door");
          if (el) {
            el.classList.remove("ok", "err");
            el.title = "Unbekannt";
          }
        }
      }

      async function pollStepper() {
        try {
          const s = await fetchJSON("/api/stepper/status");
          if (s && s.ok) {
            const bad = !!s.diag;
            const uartOk = !!s.uart_ok;
            const title = "Stepper" + (uartOk ? "" : " (UART Fehler!)");
            setBadge("b_step", !bad && uartOk, bad ? "TMC DIAG aktiv" : (uartOk ? "OK" : "UART Verbindung fehlgeschlagen"));
            
            const bBadge = $("b_step");
            if (bBadge) bBadge.textContent = title;

            // Homing Button State
            const btnH = $("stepHome");
            if (btnH) {
               if (s.homing) {
                  btnH.classList.add("success");
                  btnH.classList.remove("primary");
                  btnH.textContent = "Homing...";
                  btnH.disabled = true;
               } else {
                  btnH.classList.add("primary");
                  btnH.classList.remove("success");
                  btnH.textContent = "Homing Starten";
                  btnH.disabled = s.moving; // Disable if moving otherwise
               }
            }
            
            // Jog Buttons
            const canJog = s.lastDone && !s.homing && !s.moving;
            const btnUp = $("stepUp");
            const btnDown = $("stepDown");
            
            if (btnUp) {
               if (!btnUp.dataset.moving) {
                   btnUp.disabled = !canJog;
                   // Ensure idle state is primary (Blue/Red/Filled) as requested
                   if (!s.moving) btnUp.classList.add("primary");
               }
               // Reset text/color if not moving (and was moving)
               if (!s.moving && btnUp.dataset.moving) {
                  btnUp.textContent = "▲ 1 cm";
                  btnUp.classList.remove("success");
                  btnUp.classList.add("primary"); // Restore filled state
                  delete btnUp.dataset.moving;
               }
            }
            if (btnDown) {
               if (!btnDown.dataset.moving) {
                   btnDown.disabled = !canJog;
                   if (!s.moving) btnDown.classList.add("primary");
               }
               if (!s.moving && btnDown.dataset.moving) {
                  btnDown.textContent = "▼ 1 cm";
                  btnDown.classList.remove("success");
                  btnDown.classList.add("primary"); // Restore filled state
                  delete btnDown.dataset.moving;
               }
            }
            
          } else {
            const el = $("b_step");
            if (el) {
              el.classList.remove("ok", "err");
              el.title = "Unbekannt";
            }
          }
        } catch (_) {
          const el = $("b_step");
          if (el) {
            el.classList.remove("ok", "err");
            el.title = "Unbekannt";
          }
        }
      }

      $("btnDone").addEventListener("click", async () => {
        try {
          const r = await fetch("/api/setup/done", { method: "POST" });
          if (r.ok) {
            showToast("Setup abgeschlossen – Neustart…");
            setTimeout(() => (location.href = "/"), 2500);
          } else {
            showToast("Fehler beim Abschluss");
          }
        } catch (e) {
          showToast("Fehler: " + e.message);
        }
      });
      $("btnAbort").addEventListener("click", async () => {
        try {
          await fetch("/api/setup/abort", { method: "POST" });
          showToast("Setup abgebrochen. Du kannst später fortsetzen.");
        } catch (_) {}
      });

      connectWS();
      refreshStatus();
      setInterval(refreshStatus, 500); // Speed up
      setInterval(pollDoor, 1000);
      setInterval(pollStepper, 500); // Speed up
      updateDoneEnabled();
    </script>
  </body>
</html>